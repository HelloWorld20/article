---
title: 算法之动态规划
date: 2021-05-14 14:48:08
tags: [面试,算法,基础]
---

算法一直都是我的弱点，因为平时用不到，甚至面试也用不到（问的都是大厂，都去不了）。
现在不能再拖了。必须开始刷leetcode，系统的学一学了。

然而学到动态规划，意识到这可能是算法中最具有价值的算法了。不会动态规划的思想，有些题根本不知道怎么想。所以想记一记，其思想

<!-- more -->

# 有价值的链接

[leetcode-爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

[掘金-漫画讲解动态规划](https://juejin.cn/post/6844903520039075847)

# 思想

算法都是有其固定思路的。动态规划肯定也有。其思想指导如何解决问题。所以，动态规划的套路是：

1. 寻找最优解的子问题结构
2. 自底向上的方式解决问题
3. 定义问题的边界
4. 用缓存来记住重复的子问题

接下来用一个经典的爬楼梯问题解释其思想：

	假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
	每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

## 1. `寻找最优解的子问题结构`，

这正是最难的一部分，正是大量需要练习的部分。

题目的意思是，一次可以爬1或者2个台阶，那么到达终点，只能有两种情况：最后一步跳`一下`或者`两下`。而跳最后一步之前，也可以当作一个完整的`爬楼梯问题`，所以也可以用同样的方式分析。那么问题就很清晰的，可以用递归的方式去解决这个问题。

假设跳到第x个台阶发方法为f(x)，那么跳到第x个台阶应该是两种情况之和，即：

	f(x) = f(x-1) + f(x-2)
	
## 2. 考虑问题的边界

第二个步骤是考虑问题的边界，一般动态规划都是递归思想，所以肯定得有个边界，让其停下来。

这问题的边界就是，如果阶梯只有一阶或者两阶。

	if (n < 2) return n;

那么问题可以写出来了

```javascript
/**
 * @param {number} n
 * @return {number}
 */
function clibStairs(n) {
	if(n < 2) return n;
	
	return clibStairs(n - 1) + clibStairs(n - 2);
}
```

就这么简单。



## 3. 用缓存来存储重复的子问题

这也是动态规划普遍会遇到的问题。

加入，n=4时，

	f(4) = f(3) + f(2);
	
一直分解下去，则

	f(4) = (f(1) + f(2)) + f(2);

这时候就会有两次f(2);
如果参数更大时，重复的子问题会指数级增长。一个简单的办法就是，用个Map来缓存已经计算过的值。用空间换时间。

```javascript
const store = new Map();
function clibStairs(n) {
	if(n < 2) return n;
	
	const cache = store.get(n);
	if(cache) return cache;
	
	return clibStairs(n - 1) + clibStairs(n - 2);
}
```

这么一来，问题基本解决了。

## 4. 自底向下解决问题

作为算法学习人员，应该很明显的观察到，这题是个尾递归。尾递归可以转换为循环求解，以达到优化的目的。

这个问题无限拆解下去，最终是f(x) = ...+(f(1) + f(2));

所以自底向下解决问题，大概意思是，从f(1)、f(2)这种底部，开始逐步往上求解

那么f(3) = f(2) + f(1)。f(4) = f(3) + f(2);

可以得到

```javascript
var climbStairs = function (n) {
  if (n < 2) return n;

  let a = 1;
  let b = 2;
  let result = 2;
  while(n > 2) {
    result = a + b;
    a = b;
    b = result;
    n--;
  } 
  return result;
};
```

这个就是动态规划的终极形态了。

by the way。这个就是个斐波那契数列。


	






