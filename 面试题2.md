---
title: 面试题2
date: 2020-09-22 23:26:48
categories: 
    - 总结,面试题
tags: 
    - 总结,面试题
---

时隔约两年，又一次负责面试，但这一次难度可要大多了。可能要面2~5年经验，且水平应该在深圳中上水平的。有点慌。公司给了一些面试题范围，趁还没开始面试前，深入刷一遍面试题。以免到时出糗。。。。。

因为之前已经有过一份面试题，而且质量还不错，所以[之前的面试题](https://jianghong.site/2018/12/08/%E9%9D%A2%E8%AF%95%E9%A2%98/)提到的问题不再此篇幅提起

# HTML

### localstorage\sessionstorage\cookie区别
不赘述。但是补问

localstorage跨域传输

sessionStorage，如果打开一个新tab，新tab会不会有sessionStorage

### 盒子模型



# CSS


## 回流与重绘

# JS


## js事件以及react事件

事件冒泡与事件捕获，略

event.target：触发事件的元素
event.currentTarget: 绑定事件的元素
event.relatedTarget: 相关的第二元素。只有mouseenter、mouseleave、mouseout、mouseover、dragenter、dragexit有
其中，mouseover，移动中切换到不同子元素上就会触发。

**事件捕获只会捕获绑定事件会触发的类型

比如div中有个input。div无法捕获到input的focus事件

stopPropagation与stopImmediatePropagation

两者都可以组织网上传播事件。但是stopImmediatePropagation还会组织之后绑定的事件

### react事件（待验证）

react是自己实现的独立事件，与dom事件无关。
react事件都是绑定在document上。所以react事件都会比dom事件慢。原生事件可以阻止react事件，但是因为react事件是绑定在document上的冒泡。所以react不能阻止原生事件。

## 猜结果1

```javascript
if(!'a' in window){
	function a() {};
	console.log('ready')
}

```
答案是，不会打印ready

因为变量提升是发生在编译阶段。代码执行过程中，a以及存在window下了

## 宏任务与微任务

[宏任务与微任务](https://jianghong.site/2018/12/08/%E9%9D%A2%E8%AF%95%E9%A2%98/#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1)

## requestAnimateFrame和requestIdleFrame


## ES6 新特性



# 框架

可能每个人的框架使用范围不一样，不用准备太多

## React

## Typescirpt

## Vue

## 微信环境

### 微信H5授权流程

### 小程序授权流程

## Node

### express与koa的错误处理机制

#### express

express错误处理中间件的回调函数会多一个err参数，如果上游有错误抛出，则会触发错误处理中间件。如果没有，则不会触发

```javascript
// 正常抛出会触发
app.get('/', function(req, res, next){
	throw new Error('error')
})

app.get('/', function(req, res, next) {
	new Promsie((resolve, reject) => {
		setTimeout(() => {
			const err = new Error('custom async error');
			// 如果是异步则得在调用next时传入一个错误对象，才会触发错误处理中间件，否则进入正常中间件
			next(err);
		}, 2000)
	})
}

app.use(function(err, req, res){
	if (err) {
		在此处能接收到错误
	}
})

```

#### koa

说起koa的错误处理，得先提一下koa的洋葱模型。

![](https://image-static.segmentfault.com/289/215/2892151181-5ab48de7b5013_articlex)
![](https://image-static.segmentfault.com/247/407/2474077171-5ab493c984bf8_articlex)

洋葱的每一层都是一个中间件。然后每个请求从洋葱的外层开始一层一层进入中间件，然后再从里到外再一层一层执行。

```javascript
app.use(async (ctx, next) => {
	console.log(1)
	await next();
	console.log(2):
})

app.use(async (ctx, next) => {
	console.log(3)
	await next();
	console.log(4):
})

app.use(async (ctx, next) => {
	console.log(5)
	await next();
	console.log(6):
})
```

执行顺序是1、3、5、6、4、2

按照中间件的注册顺序 func1、func2、func3.则一次请求会按func1 => func2 => func3 => func2 => func1;

所以，错误处理中间件应该注册在第一层，然后在第一次把next方法包裹一层trycatch就能捕获其他中间件的错误。

```javascript
// 第一层中间件
app.use(async (ctx, next) => {
	try{
		await next();
	}catch(e){
		// 处理错误
	}
	await next();
	console.log(6):
})
```

## webpack

### webpack常用的配置，以及其作用

### webpack如何配置多页面

### 如果两个模块互相引用，会发生什么

webpack会根据入口，根据模块依赖不断的找到


# 其他

## http与https

https = http + ssl

### https的加密过程

先了解几个概念

#### 对称加密

加密和解密用的是同一份密钥

#### 非对称加密

加密和解密是两份密钥，分别公钥和私钥。公钥是公开的，私钥是保密的。但是非对称加密比对称加密性能低很多。

常用的有：RSA

**GitHub的ssh密钥就是经典的非对称加密

#### 哈希算法

把不同的内容转换称固定长度的字符串，是不可逆的，一般称作摘要算法

#### 数字签名

一般是请求主题主体的摘要，随信息一起发送。证明信息没有被篡改。

### 加密流程

1. 浏览器向服务器发起https请求。
2. 服务器返回公钥以及证书信息摘要
3. 浏览器去正式颁布中心获取公钥，解密服务器发来的摘要。监测是否合法证书（还是有点懵）
4. 浏览器计算一个对称加密密钥，用服务器公钥加密本地密钥
5. 把加密密钥发给服务器，服务器用非对称加密密钥解密，拿到密钥。
6. 双方用非对称加密密钥加密信息，互相交流。

至于为什么不直接用非对称加密，只是因为非对称加密性能比对称加密低很多。


## 常用的http状态码


## 前端安全


