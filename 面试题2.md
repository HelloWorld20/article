---
title: 面试题2
date: 2020-09-22 23:26:48
categories: 
    - 总结,面试题
tags: 
    - 总结,面试题
---

时隔约两年，又一次负责面试，但这一次难度可要大多了。可能要面2~5年经验，且水平应该在深圳中上水平的。有点慌。公司给了一些面试题范围，趁还没开始面试前，深入刷一遍面试题。以免到时出糗。。。。。



## express与koa的错误处理机制

### express

express错误处理中间件的回调函数会多一个err参数，如果上游有错误抛出，则会触发错误处理中间件。如果没有，则不会触发

```javascript
// 正常抛出会触发
app.get('/', function(req, res, next){
	throw new Error('error')
})

app.get('/', function(req, res, next) {
	new Promsie((resolve, reject) => {
		setTimeout(() => {
			const err = new Error('custom async error');
			// 如果是异步则得在调用next时传入一个错误对象，才会触发错误处理中间件，否则进入正常中间件
			next(err);
		}, 2000)
	})
}

app.use(function(err, req, res){
	if (err) {
		在此处能接收到错误
	}
})

```

### koa

说起koa的错误处理，得先提一下koa的洋葱模型。

![](https://image-static.segmentfault.com/289/215/2892151181-5ab48de7b5013_articlex)
![](https://image-static.segmentfault.com/247/407/2474077171-5ab493c984bf8_articlex)

洋葱的每一层都是一个中间件。然后每个请求从洋葱的外层开始一层一层进入中间件，然后再从里到外再一层一层执行。

```javascript
app.use(async (ctx, next) => {
	console.log(1)
	await next();
	console.log(2):
})

app.use(async (ctx, next) => {
	console.log(3)
	await next();
	console.log(4):
})

app.use(async (ctx, next) => {
	console.log(5)
	await next();
	console.log(6):
})
```

执行顺序是1、3、5、6、4、2

按照中间件的注册顺序 func1、func2、func3.则一次请求会按func1 => func2 => func3 => func2 => func1;

所以，错误处理中间件应该注册在第一层，然后在第一次把next方法包裹一层trycatch就能捕获其他中间件的错误。

```javascript
// 第一层中间件
app.use(async (ctx, next) => {
	try{
		await next();
	}catch(e){
		// 处理错误
	}
	await next();
	console.log(6):
})
```

## http与https

https = http + ssl

### https的加密过程

先了解几个概念

#### 对称加密

加密和解密用的是同一份密钥

#### 非对称加密

加密和解密是两份密钥，分别公钥和私钥。公钥是公开的，私钥是保密的。但是非对称加密比对称加密性能低很多。

常用的有：RSA

**GitHub的ssh密钥就是经典的非对称加密

#### 哈希算法

把不同的内容转换称固定长度的字符串，是不可逆的，一般称作摘要算法

#### 数字签名

一般是请求主题主体的摘要，随信息一起发送。证明信息没有被篡改。

### 加密流程

1. 浏览器向服务器发起https请求。
2. 服务器返回公钥以及证书信息摘要
3. 浏览器去正式颁布中心获取公钥，解密服务器发来的摘要。监测是否合法证书（还是有点懵）
4. 浏览器计算一个对称加密密钥，用服务器公钥加密本地密钥
5. 把加密密钥发给服务器，服务器用非对称加密密钥解密，拿到密钥。
6. 双方用非对称加密密钥加密信息，互相交流。

至于为什么不直接用非对称加密，只是因为非对称加密性能比对称加密低很多。

